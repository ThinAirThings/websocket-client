{"version":3,"sources":["../src/index.ts","../src/SocketioClient.ts","../src/websocketFetch.ts"],"sourcesContent":["export * from './SocketioClient'\nexport * from './websocketFetch'","import { io, Socket } from \"socket.io-client\"\nimport { nanoid } from \"nanoid\"\nimport { IncomingWebsocketRequestMessage } from \"./websocketFetch\"\nimport { rxToTx } from \"@thinairthings/txrx\"\n\nexport class SocketioClient{\n    socket!: Socket\n    connected!: Promise<boolean>\n    actions: Record<string, (payload: any)=>void> = {}\n    constructor(url: string, actions?: Record<string, (payload: any)=>void>){\n        this.socket = io(url, {forceNew: true})\n        this.actions = actions??{}\n        this.connected = new Promise<boolean>((resolve) => {\n            this.socket.on('connect', () => {\n                resolve(true)\n            })\n            this.socket.on('connect_error', this.reconnect)\n            this.socket.on('disconnect', this.reconnect)\n        })\n        this.addActions(this.actions)\n    }\n    reconnect = () => {\n        this.connected = new Promise<boolean>((resolve) => {\n            this.socket.off('connect')\n            setTimeout(() => {\n                this.socket.on('connect', ()=>{\n                    resolve(true)\n                })\n                this.socket.connect()\n            }, 1000);\n        })\n    }\n    addAction = (action: string, callback: (payload: any)=>void) => {\n        this.socket.on(rxToTx(action), callback)\n    }\n    removeAction = (action: string, callback: (payload: any)=>void) => {\n        this.socket.off(rxToTx(action), callback)\n    }\n    addActions = (actions: Record<string, (payload: any)=>void>) => {\n        for (const [action, callback] of Object.entries(actions)){\n            this.socket.on(rxToTx(action), callback)\n        }\n    }\n    removeActions = (actions: Record<string, (payload: any)=>void>) => {\n        for (const [action, callback] of Object.entries(actions)){\n            this.socket.off(rxToTx(action), callback)\n        }\n    }\n    sendMessage = async (action: string, payload?: Record<string, any>) => {\n        await this.connected\n        this.socket.emit(action, payload)\n    }\n    fetch = async <UpdatePayload extends Record<string, any>=Record<string, any>>(\n        action: string, \n        txPayload?: Record<string, any>, \n        handleUpdateMessage?: (rxPayload: UpdatePayload)=>void\n    ): Promise<Record<string, unknown>> => {\n        await this.connected\n        const messageId = nanoid()\n        return new Promise((resolve, reject) => {\n            this.socket.on(messageId, (rxMessage: IncomingWebsocketRequestMessage) => {\n                if (!rxMessage.status || rxMessage.status === 'COMPLETE') {\n                    resolve(rxMessage.payload)\n                } else if (rxMessage.status === 'RUNNING') {\n                    handleUpdateMessage?.(rxMessage.payload as UpdatePayload)\n                } else if (rxMessage.status === 'ERROR') {\n                    reject(rxMessage.payload)\n                } else {\n                    reject('Unknown data format')\n                }\n            })\n            this.socket.emit(action, {\n                action,\n                messageId,\n                ...txPayload\n            })\n        })\n    }\n}","import {nanoid} from 'nanoid'\nexport type IncomingWebsocketRequestMessage = {\n    messageId: string\n    status: 'RUNNING'|'ERROR'|'COMPLETE'\n    payload: Record<string, any>\n}\n\nexport const websocketFetch = async <UpdatePayload extends Record<string, any>=Record<string, any>>({\n    url,\n    action, \n    payload, \n    handleUpdateMessage\n}: {\n    url: string, \n    action: string, \n    payload?: Record<string, any>, \n    handleUpdateMessage?: (payload: UpdatePayload)=>void\n}): Promise<Record<string, unknown>> => {\n    const messageId = nanoid()\n    return new Promise((resolve, reject) => {\n        const websocket = new WebSocket(url)\n        websocket.onopen = () => {\n            websocket.onmessage = (event) => {\n                const data = JSON.parse(event.data) as IncomingWebsocketRequestMessage\n                if (data.messageId === messageId) {\n                    if (data.status === 'RUNNING') {\n                        handleUpdateMessage?.(data.payload as UpdatePayload)\n                    } else if (data.status === 'COMPLETE') {\n                        resolve(data.payload)\n                        websocket.close()\n                    } else if (data.status === 'ERROR') {\n                        reject(data.payload)\n                        websocket.close()\n                    } else {\n                        reject('Unknown status')\n                        websocket.close()\n                    }\n                }\n            }\n            websocket.send(JSON.stringify({\n                action,\n                messageId,\n                ...payload\n            }))\n        }\n    })\n}"],"mappings":"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","names":["import_nanoid"]}